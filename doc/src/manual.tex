% File              : manual.tex
% Author            : Marcos Horro <marcos.horro@udc.gal>
% Date              : Mar 24 Dec 2019 19:31:10 MST
% Last Modified Date: MÃ©r 25 Dec 2019 18:35:55 MST
% Last Modified By  : Marcos Horro <marcos.horro@udc.gal>
\documentclass[a4paper,12pt]{memoir}
% For TeXstudio users:
% !TeX spellcheck = en_US

\usepackage[ruled,vlined]{algorithm2e}
\usepackage{graphicx}
\usepackage{amsthm}

%\theoremstyle{definition}
\newtheorem{definition}{Definition}[]
\newtheorem{corollary}{Corollary}[]




% Title Page
\title{\textbf{MACVETH}: \textbf{M}ulti-dimensional \textbf{A}rray
    \textbf{C}-compiler for \textbf{VE}ctorization and
    \textbf{T}ransformation in \textbf{H}PC applications}
\author{Marcos Horro}
\date{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
This document presents the Multi-dimensional Array C-compiler for VEctorization 
and Transformation in HPC applications (MACVETH) compiler tool. Details 
regarding implementation and design decision are explained in detail. For 
specific implementation details refer to the proper source code, which is also 
documented using Doxygen.
\end{abstract}

\chapter{Description}

Despite of the extraordinary performance with regard to the optimizations that compilers (e.g. ICC, LLVM, gcc) may be able to do all over programs, they also show limitations when it comes to vectorization. There are cases where either they may not vectorize the code at all or even deliver worse performance than a sequential version of it. This is a common scenario when the region of interest in the code to vectorize is not regular. We may define the regularity of a code as the presence of patterns whose accesses to the elements (e.g. multi-dimensional arrays) are performed in a sequential and contiguous manner, e.g. map operations. On the other hand, reductions are special types of operations that do not fully exploit the capacity of vector operands. Current data placement or packing techniques are meant just for loading and storing data from or to memory, without performing any other logic than that. Potential improvements regarding the vector occupancy by complex and smart packing techniques may lead to major gains in performance. Picture the following example: within the same loop we have two different and contiguous reductions. This is a common pattern that can be found after the fusion of different loops, for instance, in codes that perform convolutions. Assuming a vector size of four elements, a smart way of computing this code is by 

% Different ISA
In an orthogonal dimension, the quality of SIMD code is affected by the knowledge of the architecture where it is being compiled. Nevertheless, some information regarding the SIMD instructions performance may be missing or non-disclosed by the manufacturer. This information can be used to determine whether a vector operation is detrimental or not, i.e. for building a cost model. There may be architectures using the same ISA and, therefore, where the vectorization can be done using exactly the same instructions, but because of their architectural designs the performance may be different, leading to different approaches on each case. Thus, the only manner of disclosing this information is by reverse-engineering each architecture. This process is tedious and complex since there are many different instructions whose performance may be also vary depending on the packing of the data they use.


MACVETH is a source-to-source compiler which targets the vectorization of C/C++ 
codes. Thus, the input of this compiler is a non vectorized C/C++ code and the 
output will be a SIMD-fashion C/C++ code (see Figure~\ref{fig:MACVETHarch}). 
The name of the compiler stands for Multi-dimensional Array C-compiler for 
VEctorization and Transformation in HPC applications. Besides, Macbeth, tragedy 
written by William Shakespeare, represents the detrimental effects of human's 
narcissism and vanity when looking for the power for its own benefits. As 
opposed, MACVETH is composed by a set different layers and intermediate 
representations that seek for the common purpose of improving performance. Last 
but not least, the first and last letter of the acronym stand for the name of 
the main author (Marcos Horro).

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{img/MACVETH.pdf}
	\caption{High-level picture of the MACVETH pipeline compiler.}
	\label{fig:MACVETHarch}
\end{figure}

\chapter{MACVETH IR}



This compiler handles different abstraction levels or intermediate
representations for each step. As MACVETH is based in Clang~\cite{bib:clang},
the first abstraction layer lays on the Clang AST. This representation allows to
identify the regions of interest for the translation.

\section{MACVETH Expressions: MVExpr}
Clang implements complex expressions in order to handle any form or type of 
code. They 
provide many possibilities
when it comes to parse exactly the code. Nonetheless, in our case we are
interested in a small set of operations, so we created basically a wrap for this
purpose. MVExpr is an abstract class that can be specialized for any type we
want to represent from the Clang AST. Besides, the idea of this class is to
provide a set of non-standard transformations for the expressions, e.g.
unrolling.

\section{Three-Address Code IR: TAC}
The Three-Address Code (TAC) representation used translates any statement ($S$) 
into a
set of Single Stament Assignment (SSA) using quadruples, as described in 
Definition~\ref{def:TAC}.

\theoremstyle{definition}
\begin{definition}\label{def:TAC}
	A three-address code is a 4-tuple TAC=(a,b,c,$\oplus$) which represents the 
	assignment of the $b \oplus c$ operation as $a
	= 
	b \oplus c$. If the $\oplus$ operator is unary then $c$ is null.
\end{definition}

In order to perform this translation, we have implemented the recursive process 
is listed in 
Algorithm~\ref{alg:stmtToTAC}. Each statement may be composed by a 
concatenation of operations, which are split onto TACs respecting the 
operational order. Therefore, we can conclude that any statement 
can be represented as a set of TACs (formally stated in 
Corollary~\ref{cor:TAC}).

\begin{algorithm}[H]\label{alg:stmtToTAC}
	\SetAlgoLined
	\KwIn{Stmt S}
	\KwResult{Set of TAC}
	Lhs $\leftarrow$ getLHS(S)\;
	Rhs $\leftarrow$ getRHS(S)\;
	\If{isDivisible(Lhs)}{
		TAC $\leftarrow$ translateStmtToTAC(Lhs)\;
	}
	\If{isDivisible(Rhs)}{
		TAC $\leftarrow$ translateStmtToTAC(Rhs)\;
	}
	addTacToList(TAC)\;
	\caption{Translation from statement to TAC format (translateStmtToTAC)}
\end{algorithm}

\begin{corollary}\label{cor:TAC}
	Any statement can be represented as a set of TACs:
	$S = \{TAC\}$
\end{corollary}

This representation is widely used in compilers. The main advantages of it 
resides in the simplicity of handling operations with the same number of 
operands. 

Unrolling is also performed using this format, following the iterative process 
listed in 
Algorithm~\ref{alg:TACunrolling}.

\begin{algorithm}[H]\label{alg:TACunrolling}
	\SetAlgoLined
	\KwIn{Set of TAC, Unrolling factor, Loop nests}
	\KwResult{Set of TAC}
	\caption{Unrolling set of TAC}
\end{algorithm}


\section{Computational Directed Acyclic Graph (CDAG)}
When it comes to schedule the different TACs in the ROI of our program, we need
a representation which can handle the dependencies between the statements and
some structures that store the information about the placement of them in the
execution. For this purpose we use a Computational Directed Acyclic Graph or 
CDAG~\cite{bib:CDAGdefinition}. Informally, it is a forest that represents the 
TACs as a set of nodes, where 
each node can be a memory operation (load, store) or any other type of 
operation (addition, multiplication, built-in function, etc.). Connections 
between those nodes represent data dependencies. Formal 
definition of the CDAG we have implemented can be found in 
Definition~\ref{def:CDAG}. It is, essentially, a slight variation 
of the definition given in~\cite{bib:CDAGdefinition}.

\theoremstyle{definition}
\begin{definition}\label{def:CDAG}
	A computation directed acyclic graph (CDAG) is a 4-tuple C=(I,V,E,O) of 
	finite sets such that: (1) $I \subseteq V, O \subseteq V$; (2) $E 
	\subseteq V 
	\times V$ is the set of arcs; (3) $G=(V,E) \subseteq C$
\end{definition}


\section{VectorIR}
In order to approach the different architectures when generating instructions,
we need a generic vector representation of the vector instructions we want to
have in our program. For this purpose, MACVETH uses the VectorIR, that basically
wraps a set of nodes from the CDAG onto a common structure which represent a vector operation.

To wrap up: VectorIR is a generic way of representing vector operations for the different
architectures. Because of this, at this stage there is no fusing operations or
any other kind of target-specific optimizations. The concrete backend will be in
charge of doing this.

\chapter{SIMD backend: instruction generation}
For generating the SIMD instructions for each concrete architecture, MACVETH
uses the VectorIR described above.

\chapter{$\mu$bench}
The process of reverse-engineering is complex and tedious, as it requires

\bibliographystyle{unsrt}
\bibliography{sample}

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
